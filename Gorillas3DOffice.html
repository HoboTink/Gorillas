<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gorillas Office Edition - Workplace Chaos!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            max-width: 1400px;
            aspect-ratio: 16 / 9;
            background: #000;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* UI Overlay */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-ui {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px;
            background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 100%);
            pointer-events: none;
        }

        .score-box {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #FF6B6B;
            min-width: 150px;
            text-align: center;
        }

        .score-box.active {
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        #wind-indicator {
            background: rgba(0, 0, 0, 0.7);
            color: #FFD700;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #FFD700;
            text-align: center;
        }

        #projectile-display {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #4CAF50;
            text-align: center;
        }

        #bottom-ui {
            background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.8) 100%);
            padding: 30px 20px 20px 20px;
            pointer-events: auto;
        }

        #controls-panel {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            max-width: 900px;
            margin: 0 auto;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(30, 30, 30, 0.9);
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid #4CAF50;
        }

        .control-group label {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
        }

        .control-group input {
            width: 70px;
            padding: 8px 12px;
            border: 1px solid #4CAF50;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: #4CAF50;
            font-weight: bold;
            font-size: 14px;
        }

        .control-group select {
            padding: 8px 12px;
            border: 1px solid #4CAF50;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: #4CAF50;
            font-weight: bold;
            font-size: 14px;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        button {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #throw-btn {
            background: linear-gradient(135deg, #FF6B6B, #FF5252);
            color: white;
            pointer-events: auto;
        }

        #throw-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #FF5252, #FF3838);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.6);
            transform: scale(1.05);
        }

        #throw-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        #reset-btn {
            background: linear-gradient(135deg, #ff9800, #e68900);
            color: white;
            pointer-events: auto;
        }

        #reset-btn:hover {
            background: linear-gradient(135deg, #e68900, #d97700);
            box-shadow: 0 0 20px rgba(255, 152, 0, 0.6);
            transform: scale(1.05);
        }

        #turn-indicator {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 20px;
            border-radius: 8px;
            border: 2px solid #FF6B6B;
        }

        #center-ui {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            pointer-events: auto;
        }

        #game-message {
            background: rgba(0, 0, 0, 0.9);
            color: #FFD700;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 48px;
            font-weight: bold;
            text-align: center;
            border: 3px solid #FFD700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            display: none;
            animation: popIn 0.5s ease-out;
        }

        @keyframes popIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #aaa;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid #555;
            max-width: 250px;
            pointer-events: auto;
        }

        .info-line {
            margin: 5px 0;
        }

        .info-line strong {
            color: #FF6B6B;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-overlay">
            <div id="top-ui">
                <div class="score-box" id="p1-score-box">
                    <div style="font-size: 12px; color: #aaa; margin-bottom: 5px;">GORILLA 1</div>
                    <div id="p1-score">0</div>
                </div>
                <div id="wind-indicator">
                    <div style="font-size: 12px; color: #aaa; margin-bottom: 5px;">AIR FLOW</div>
                    <div id="wind-value">0</div>
                </div>
                <div id="projectile-display">
                    <div style="font-size: 12px; color: #aaa; margin-bottom: 5px;">AMMO</div>
                    <div id="projectile-name">Sticky Notes</div>
                </div>
                <div class="score-box" id="p2-score-box">
                    <div style="font-size: 12px; color: #aaa; margin-bottom: 5px;">GORILLA 2</div>
                    <div id="p2-score">0</div>
                </div>
            </div>

            <div id="center-ui">
                <div id="game-message"></div>
            </div>

            <div id="bottom-ui">
                <div id="turn-indicator">Gorilla 1's Turn</div>
                <div id="controls-panel">
                    <div class="control-group">
                        <label>Angle (Â°):</label>
                        <input type="number" id="angle-input" min="0" max="180" value="45" step="5">
                    </div>
                    <div class="control-group">
                        <label>Power:</label>
                        <input type="number" id="power-input" min="20" max="200" value="80" step="5">
                    </div>
                    <div class="control-group">
                        <label>Ammo:</label>
                        <select id="projectile-select">
                            <option value="sticky">Sticky Notes</option>
                            <option value="stapler">Stapler</option>
                            <option value="paper">Paper Airplane</option>
                        </select>
                    </div>
                    <button id="throw-btn">FIRE!</button>
                    <button id="reset-btn">NEW GAME</button>
                </div>
            </div>

            <div id="instructions">
                <div class="info-line"><strong>Drag:</strong> Rotate camera</div>
                <div class="info-line"><strong>Shift + Drag:</strong> Tilt camera</div>
                <div class="info-line"><strong>Scroll:</strong> Zoom in/out</div>
                <div class="info-line"><strong>WASD:</strong> Pan camera</div>
                <div class="info-line"><strong>Space:</strong> Reset camera</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // GORILLAS OFFICE EDITION - WORKPLACE CHAOS!
        // ============================================

        // Projectile types with different physics
        const projectileTypes = {
            sticky: {
                name: 'Sticky Notes',
                mass: 0.5,
                size: 2,
                color: 0xFFFF00,
                gravity: 5.0,
                windMultiplier: 1.5,
                maxDamage: 10,
                effect: 'sticks'
            },
            stapler: {
                name: 'Stapler',
                mass: 2.0,
                size: 3,
                color: 0x333333,
                gravity: 10.0,
                windMultiplier: 0.3,
                maxDamage: 50,
                effect: 'damage'
            },
            paper: {
                name: 'Paper Airplane',
                mass: 0.2,
                size: 1.5,
                color: 0xFFFFFF,
                gravity: 3.0,
                windMultiplier: 2.0,
                maxDamage: 5,
                effect: 'annoy'
            }
        };

        class GorillasOffice {
            constructor() {
                // Canvas and Renderer
                this.canvas = document.getElementById('gameCanvas');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: true });

                this.setupRenderer();
                this.setupLighting();
                this.setupEnvironment();

                // Game State
                this.gameState = {
                    currentPlayer: 1,
                    score: { 1: 0, 2: 0 },
                    wind: 0,
                    isAnimating: false,
                    projectile: null,
                    projectileType: 'sticky'
                };

                // Game Objects
                this.furniture = [];
                this.gorillas = {};
                this.officeLocations = [];
                this.physics = {
                    gravity: 9.81,
                    windForce: 0.5
                };

                // Camera control
                this.cameraControl = {
                    enabled: true,
                    isDragging: false,
                    isRightDragging: false,
                    previousMousePosition: { x: 0, y: 0 },
                    rotation: { x: 0, y: 0, z: 0 },
                    zoom: 50,
                    panX: 0,
                    panY: 0
                };

                this.init();
            }

            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFShadowShadowMap;
                this.renderer.setClearColor(0xeaeaea);

                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupLighting() {
                // Ambient light for office
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                this.scene.add(ambientLight);

                // Directional light (ceiling lights)
                const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
                sunLight.position.set(50, 50, 50);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.width = 4096;
                sunLight.shadow.mapSize.height = 4096;
                sunLight.shadow.camera.left = -100;
                sunLight.shadow.camera.right = 100;
                sunLight.shadow.camera.top = 100;
                sunLight.shadow.camera.bottom = -100;
                this.scene.add(sunLight);
            }

            setupEnvironment() {
                // Office floor
                const floorGeometry = new THREE.PlaneGeometry(100, 80);
                const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                floor.receiveShadow = true;
                this.scene.add(floor);

                // Office walls
                this.createWall(0, 0, 50, 40, 3, 0xe0e0e0); // Back wall
                this.createWall(0, 0, -50, 40, 3, 0xe0e0e0); // Front wall
                this.createWall(-50, 0, 0, 80, 3, 0xe0e0e0); // Left wall
                this.createWall(50, 0, 0, 80, 3, 0xe0e0e0); // Right wall
            }

            createWall(x, y, z, width, height, color) {
                const geometry = new THREE.BoxGeometry(width, height, 0.5);
                const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7 });
                const wall = new THREE.Mesh(geometry, material);
                wall.position.set(x, y, z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                this.scene.add(wall);
            }

            init() {
                this.generateOffice();
                this.createGorillas();
                this.randomizeWind();
                this.updateUI();
                this.setupControls();
                this.resetCamera();
                this.animate();
            }

            generateOffice() {
                // Remove old furniture
                this.furniture.forEach(f => this.scene.remove(f));
                this.furniture = [];
                this.officeLocations = [];

                // Create office layout: desks, cabinets, meeting table
                // Scattered desks
                for (let i = 0; i < 6; i++) {
                    const x = (Math.random() - 0.5) * 70;
                    const z = (Math.random() - 0.5) * 50;
                    const desk = this.createDesk(x, z);
                    this.furniture.push(desk);
                    this.officeLocations.push({ x: x, z: z, type: 'desk', height: 3 });
                }

                // Meeting table in center
                const meetingTable = this.createMeetingTable(0, 0);
                this.furniture.push(meetingTable);
                this.officeLocations.push({ x: 0, z: 0, type: 'meeting', height: 3 });

                // Storage cabinets on perimeter
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const x = Math.cos(angle) * 40;
                    const z = Math.sin(angle) * 35;
                    const cabinet = this.createCabinet(x, z);
                    this.furniture.push(cabinet);
                    this.officeLocations.push({ x: x, z: z, type: 'cabinet', height: 6 });
                }

                // Office partitions
                for (let i = 0; i < 5; i++) {
                    const x = (Math.random() - 0.5) * 60;
                    const z = (Math.random() - 0.5) * 40;
                    const partition = this.createPartition(x, z);
                    this.furniture.push(partition);
                }
            }

            createDesk(x, z) {
                const group = new THREE.Group();
                group.position.set(x, 0, z);

                const deskGeometry = new THREE.BoxGeometry(8, 0.5, 4);
                const deskMaterial = new THREE.MeshStandardMaterial({ color: 0x8B6F47, roughness: 0.6 });
                const deskMesh = new THREE.Mesh(deskGeometry, deskMaterial);
                deskMesh.position.y = 1.5;
                deskMesh.castShadow = true;
                deskMesh.receiveShadow = true;
                group.add(deskMesh);

                // Desk leg
                const legGeometry = new THREE.BoxGeometry(0.3, 3, 0.3);
                const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.y = 0.8;
                leg.castShadow = true;
                group.add(leg);

                // Create destructible segments
                group.userData = {
                    type: 'desk',
                    width: 8,
                    height: 3,
                    segments: [],
                    bounds: { minX: -4, maxX: 4, minY: -1.5, maxY: 1.5, minZ: -2, maxZ: 2 }
                };

                const segmentSize = 5;
                for (let y = 0; y < 1; y++) {
                    for (let x = 0; x < 2; x++) {
                        const segWidth = 4;
                        const segHeight = 3;
                        const segDepth = 4;

                        const geometry = new THREE.BoxGeometry(segWidth, segHeight, segDepth);
                        const material = new THREE.MeshStandardMaterial({ color: 0x8B6F47, roughness: 0.6 });
                        const segment = new THREE.Mesh(geometry, material);
                        segment.position.set(-2 + x * 4, 0, 0);
                        segment.castShadow = true;
                        segment.receiveShadow = true;

                        group.add(segment);
                        group.userData.segments.push({ mesh: segment, intact: true });
                    }
                }

                this.scene.add(group);
                return group;
            }

            createMeetingTable(x, z) {
                const group = new THREE.Group();
                group.position.set(x, 0, z);

                const tableGeometry = new THREE.BoxGeometry(15, 0.5, 8);
                const tableMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.6 });
                const tableMesh = new THREE.Mesh(tableGeometry, tableMaterial);
                tableMesh.position.y = 1.5;
                tableMesh.castShadow = true;
                tableMesh.receiveShadow = true;
                group.add(tableMesh);

                group.userData = {
                    type: 'meeting',
                    width: 15,
                    height: 3,
                    segments: [],
                    bounds: { minX: -7.5, maxX: 7.5, minY: -1.5, maxY: 1.5, minZ: -4, maxZ: 4 }
                };

                this.scene.add(group);
                return group;
            }

            createCabinet(x, z) {
                const group = new THREE.Group();
                group.position.set(x, 0, z);

                const cabinetGeometry = new THREE.BoxGeometry(5, 6, 2);
                const cabinetMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.7 });
                const cabinetMesh = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
                cabinetMesh.position.y = 3;
                cabinetMesh.castShadow = true;
                cabinetMesh.receiveShadow = true;
                group.add(cabinetMesh);

                group.userData = {
                    type: 'cabinet',
                    width: 5,
                    height: 6,
                    segments: [],
                    bounds: { minX: -2.5, maxX: 2.5, minY: 0, maxY: 6, minZ: -1, maxZ: 1 }
                };

                this.scene.add(group);
                return group;
            }

            createPartition(x, z) {
                const group = new THREE.Group();
                group.position.set(x, 0, z);

                const partitionGeometry = new THREE.BoxGeometry(6, 4, 0.5);
                const partitionMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.6 });
                const partitionMesh = new THREE.Mesh(partitionGeometry, partitionMaterial);
                partitionMesh.position.y = 2;
                partitionMesh.castShadow = true;
                partitionMesh.receiveShadow = true;
                group.add(partitionMesh);

                this.scene.add(group);
                return group;
            }

            createGorillas() {
                // Remove old gorillas
                if (this.gorillas[1]) this.scene.remove(this.gorillas[1]);
                if (this.gorillas[2]) this.scene.remove(this.gorillas[2]);

                // Randomly place gorillas in office locations
                const validLocations = this.officeLocations.filter(loc => loc.type !== 'cabinet');
                const loc1 = validLocations[Math.floor(Math.random() * validLocations.length)];
                let loc2 = validLocations[Math.floor(Math.random() * validLocations.length)];
                while (loc2 === loc1 && validLocations.length > 1) {
                    loc2 = validLocations[Math.floor(Math.random() * validLocations.length)];
                }

                this.gorillas[1] = this.createGorilla();
                this.gorillas[1].position.set(loc1.x, loc1.height, loc1.z);
                this.scene.add(this.gorillas[1]);

                this.gorillas[2] = this.createGorilla();
                this.gorillas[2].position.set(loc2.x, loc2.height, loc2.z);
                this.scene.add(this.gorillas[2]);
            }

            createGorilla() {
                const group = new THREE.Group();

                // Body
                const bodyGeometry = new THREE.BoxGeometry(2, 3, 1.5);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0;
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(1.2, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.2;
                head.castShadow = true;
                head.receiveShadow = true;
                group.add(head);

                // Arms
                const armGeometry = new THREE.BoxGeometry(0.6, 2.5, 0.6);
                const armMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-1.5, 0.5, 0);
                leftArm.castShadow = true;
                group.add(leftArm);

                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(1.5, 0.5, 0);
                rightArm.castShadow = true;
                group.add(rightArm);

                return group;
            }

            randomizeWind() {
                this.gameState.wind = (Math.random() - 0.5) * 30;
                document.getElementById('wind-value').textContent = Math.abs(Math.floor(this.gameState.wind)).toFixed(0);
            }

            setupControls() {
                document.getElementById('throw-btn').addEventListener('click', () => this.throwProjectile());
                document.getElementById('reset-btn').addEventListener('click', () => this.resetGame());
                document.getElementById('projectile-select').addEventListener('change', (e) => {
                    this.gameState.projectileType = e.target.value;
                    this.updateProjectileDisplay();
                });

                document.addEventListener('mousedown', (e) => this.onMouseDown(e));
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
                document.addEventListener('mouseup', () => this.onMouseUp());
                document.addEventListener('wheel', (e) => this.onScroll(e), { passive: false });
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
            }

            onMouseDown(e) {
                if (e.button === 0) {
                    if (e.shiftKey) {
                        this.cameraControl.isRightDragging = true;
                    } else {
                        this.cameraControl.isDragging = true;
                    }
                }
                this.cameraControl.previousMousePosition = { x: e.clientX, y: e.clientY };
            }

            onMouseMove(e) {
                if (!this.cameraControl.enabled) return;

                const deltaX = e.clientX - this.cameraControl.previousMousePosition.x;
                const deltaY = e.clientY - this.cameraControl.previousMousePosition.y;

                if (this.cameraControl.isDragging) {
                    this.cameraControl.rotation.y += deltaX * 0.005;
                    this.cameraControl.rotation.x += deltaY * 0.005;
                    this.cameraControl.rotation.x = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, this.cameraControl.rotation.x));
                }

                if (this.cameraControl.isRightDragging) {
                    this.cameraControl.rotation.z += deltaX * 0.005;
                    this.cameraControl.rotation.z = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, this.cameraControl.rotation.z));
                }

                this.cameraControl.previousMousePosition = { x: e.clientX, y: e.clientY };
                this.updateCameraPosition();
            }

            onMouseUp() {
                this.cameraControl.isDragging = false;
                this.cameraControl.isRightDragging = false;
            }

            onScroll(e) {
                e.preventDefault();
                this.cameraControl.zoom += e.deltaY * 0.1;
                this.cameraControl.zoom = Math.max(15, Math.min(150, this.cameraControl.zoom));
                this.updateCameraPosition();
            }

            onKeyDown(e) {
                const panSpeed = 5;
                switch(e.key.toUpperCase()) {
                    case 'W': this.cameraControl.panY += panSpeed; break;
                    case 'S': this.cameraControl.panY -= panSpeed; break;
                    case 'A': this.cameraControl.panX -= panSpeed; break;
                    case 'D': this.cameraControl.panX += panSpeed; break;
                    case ' ': this.resetCamera(); break;
                }
                this.updateCameraPosition();
            }

            updateCameraPosition() {
                const x = Math.sin(this.cameraControl.rotation.y) * Math.cos(this.cameraControl.rotation.x) * this.cameraControl.zoom;
                const y = Math.sin(this.cameraControl.rotation.x) * this.cameraControl.zoom;
                const z = Math.cos(this.cameraControl.rotation.y) * Math.cos(this.cameraControl.rotation.x) * this.cameraControl.zoom;

                this.camera.position.set(
                    x + this.cameraControl.panX,
                    y + this.cameraControl.panY + 5,
                    z
                );

                const targetPos = new THREE.Vector3(this.cameraControl.panX, this.cameraControl.panY + 2, 0);
                this.camera.lookAt(targetPos);

                if (this.cameraControl.rotation.z !== 0) {
                    this.camera.rotateZ(this.cameraControl.rotation.z);
                }
            }

            resetCamera() {
                this.cameraControl.rotation = { x: -0.5, y: 0, z: 0 };
                this.cameraControl.zoom = 50;
                this.cameraControl.panX = 0;
                this.cameraControl.panY = 0;
                this.updateCameraPosition();
            }

            throwProjectile() {
                if (this.gameState.isAnimating) return;

                const angle = parseFloat(document.getElementById('angle-input').value);
                const power = parseFloat(document.getElementById('power-input').value);
                const projectileType = projectileTypes[this.gameState.projectileType];

                const gorilla = this.gorillas[this.gameState.currentPlayer];
                const angleRad = (angle * Math.PI) / 180;

                this.gameState.projectile = {
                    type: this.gameState.projectileType,
                    projectileData: projectileType,
                    position: new THREE.Vector3(gorilla.position.x, gorilla.position.y + 0.5, gorilla.position.z),
                    velocity: new THREE.Vector3(
                        Math.sin(this.gameState.currentPlayer === 1 ? angleRad : Math.PI - angleRad) * power,
                        Math.cos(angleRad) * power,
                        0
                    ),
                    rotation: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2
                    ),
                    rotationVelocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    ),
                    mesh: this.createProjectileMesh(projectileType)
                };

                this.scene.add(this.gameState.projectile.mesh);
                this.gameState.isAnimating = true;
                document.getElementById('throw-btn').disabled = true;
                this.cameraControl.enabled = false;
            }

            createProjectileMesh(projectileData) {
                const size = projectileData.size;
                const geometry = new THREE.BoxGeometry(size, size * 0.7, size * 0.5);
                const material = new THREE.MeshStandardMaterial({
                    color: projectileData.color,
                    emissive: projectileData.color,
                    emissiveIntensity: 0.2
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                return mesh;
            }

            updateProjectile() {
                if (!this.gameState.projectile) return;

                const p = this.gameState.projectile;
                const projData = p.projectileData;
                const dt = 0.016;

                // Apply physics with projectile-specific properties
                p.velocity.x += (this.gameState.wind * this.physics.windForce * projData.windMultiplier) * dt;
                p.velocity.y -= (this.physics.gravity * projData.mass) * dt;

                // Update position
                p.position.x += p.velocity.x * dt;
                p.position.y += p.velocity.y * dt;

                // Update rotation
                p.rotation.x += p.rotationVelocity.x;
                p.rotation.y += p.rotationVelocity.y;
                p.rotation.z += p.rotationVelocity.z;
                p.rotationVelocity.multiplyScalar(0.99);

                p.mesh.position.copy(p.position);
                p.mesh.rotation.set(p.rotation.x, p.rotation.y, p.rotation.z);

                // Check bounds
                if (p.position.y < -10 || Math.abs(p.position.x) > 60 || Math.abs(p.position.z) > 50) {
                    this.endTurn();
                    return;
                }

                // Check furniture collisions
                for (let furniture of this.furniture) {
                    if (this.checkFurnitureCollision(p.position, furniture)) {
                        this.createExplosion(p.position);
                        if (furniture.userData.segments) {
                            this.destroyFurnitureSegments(p.position, furniture);
                        }
                        this.endTurn();
                        return;
                    }
                }

                // Check gorilla collisions
                for (let player = 1; player <= 2; player++) {
                    if (player === this.gameState.currentPlayer) continue;
                    if (this.checkGorillaCollision(p.position, this.gorillas[player])) {
                        this.createExplosion(p.position);
                        this.applyHitEffect(projData.effect, this.gorillas[player]);
                        this.handleWin(player === 1 ? 2 : 1);
                        return;
                    }
                }
            }

            checkFurnitureCollision(pos, furniture) {
                const fPos = furniture.position;
                const bounds = furniture.userData.bounds;

                return pos.x > fPos.x + bounds.minX &&
                       pos.x < fPos.x + bounds.maxX &&
                       pos.y > fPos.y + bounds.minY &&
                       pos.y < fPos.y + bounds.maxY &&
                       pos.z > fPos.z + bounds.minZ &&
                       pos.z < fPos.z + bounds.maxZ;
            }

            destroyFurnitureSegments(impactPos, furniture) {
                const destructionRadius = 15;

                furniture.userData.segments.forEach(segment => {
                    if (!segment.intact) return;

                    const segmentWorldPos = new THREE.Vector3();
                    segment.mesh.getWorldPosition(segmentWorldPos);

                    const distance = impactPos.distanceTo(segmentWorldPos);

                    if (distance < destructionRadius) {
                        segment.intact = false;
                        furniture.remove(segment.mesh);
                    }
                });
            }

            checkGorillaCollision(pos, gorilla) {
                const distance = pos.distanceTo(gorilla.position);
                return distance < 1.5;
            }

            applyHitEffect(effect, gorilla) {
                // Effects for different projectiles
                if (effect === 'sticks') {
                    // Sticky notes - visual effect
                    const stickyColor = 0xFFFF00;
                    this.flashGorilla(gorilla, stickyColor, 1000);
                } else if (effect === 'damage') {
                    // Stapler - immediate elimination
                    this.flashGorilla(gorilla, 0xFF0000, 500);
                } else if (effect === 'annoy') {
                    // Paper airplane - shake effect
                    this.shakeScreen(300);
                }
            }

            flashGorilla(gorilla, color, duration) {
                const originalColor = gorilla.children[0].material.color.getHex();
                gorilla.children[0].material.color.setHex(color);
                setTimeout(() => {
                    gorilla.children[0].material.color.setHex(originalColor);
                }, duration);
            }

            shakeScreen(duration) {
                const originalCamPos = this.camera.position.clone();
                const shakeStart = Date.now();

                const shakeInterval = setInterval(() => {
                    const elapsed = Date.now() - shakeStart;
                    if (elapsed > duration) {
                        this.camera.position.copy(originalCamPos);
                        clearInterval(shakeInterval);
                        return;
                    }

                    const progress = 1 - (elapsed / duration);
                    const shakeX = (Math.random() - 0.5) * 2 * progress;
                    const shakeY = (Math.random() - 0.5) * 2 * progress;
                    const shakeZ = (Math.random() - 0.5) * 2 * progress;

                    this.camera.position.set(
                        originalCamPos.x + shakeX,
                        originalCamPos.y + shakeY,
                        originalCamPos.z + shakeZ
                    );
                }, 16);
            }

            createExplosion(position) {
                const particleCount = 20;
                const colors = [0xff4444, 0xffaa00, 0xffff00];

                for (let i = 0; i < particleCount; i++) {
                    const size = 0.3 + Math.random() * 0.5;
                    const geometry = new THREE.SphereGeometry(size, 6, 6);
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);

                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 50,
                        Math.random() * 30 + 10,
                        (Math.random() - 0.5) * 50
                    );

                    particle.velocity = velocity;
                    particle.gravity = 20;
                    particle.lifetime = 500;
                    particle.createdAt = Date.now();
                    this.scene.add(particle);

                    const animateParticle = () => {
                        const age = Date.now() - particle.createdAt;
                        const progress = age / particle.lifetime;

                        if (progress >= 1) {
                            this.scene.remove(particle);
                            return;
                        }

                        particle.velocity.y -= particle.gravity * 0.016;
                        particle.position.add(particle.velocity.clone().multiplyScalar(0.016));
                        particle.material.opacity = Math.max(0, 1 - progress);

                        requestAnimationFrame(animateParticle);
                    };

                    animateParticle();
                }
            }

            handleWin(winner) {
                this.gameState.score[winner]++;
                this.showMessage(`GORILLA ${winner} WINS!`);
                this.updateUI();
                this.gameState.isAnimating = false;
                this.gameState.projectile = null;

                setTimeout(() => this.resetRound(), 3000);
            }

            endTurn() {
                if (this.gameState.projectile && this.gameState.projectile.mesh) {
                    this.scene.remove(this.gameState.projectile.mesh);
                }
                this.gameState.projectile = null;
                this.gameState.isAnimating = false;
                this.gameState.currentPlayer = this.gameState.currentPlayer === 1 ? 2 : 1;
                this.randomizeWind();
                this.updateUI();
                document.getElementById('throw-btn').disabled = false;
                this.cameraControl.enabled = true;
            }

            showMessage(text) {
                const msg = document.getElementById('game-message');
                msg.textContent = text;
                msg.style.display = 'block';
                setTimeout(() => msg.style.display = 'none', 2500);
            }

            updateProjectileDisplay() {
                const projName = projectileTypes[this.gameState.projectileType].name;
                document.getElementById('projectile-name').textContent = projName;
            }

            updateUI() {
                document.getElementById('p1-score').textContent = this.gameState.score[1];
                document.getElementById('p2-score').textContent = this.gameState.score[2];

                const p1Box = document.getElementById('p1-score-box');
                const p2Box = document.getElementById('p2-score-box');
                p1Box.classList.toggle('active', this.gameState.currentPlayer === 1);
                p2Box.classList.toggle('active', this.gameState.currentPlayer === 2);

                const turnInd = document.getElementById('turn-indicator');
                turnInd.textContent = `Gorilla ${this.gameState.currentPlayer}'s Turn`;
                turnInd.style.color = this.gameState.currentPlayer === 1 ? '#FF6B6B' : '#4488FF';

                this.updateProjectileDisplay();
            }

            resetRound() {
                this.generateOffice();
                this.createGorillas();
                this.randomizeWind();
                this.resetCamera();
                this.updateUI();
            }

            resetGame() {
                this.gameState.score = { 1: 0, 2: 0 };
                this.gameState.currentPlayer = 1;
                this.resetRound();
            }

            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.updateProjectile();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize game
        window.addEventListener('load', () => {
            new GorillasOffice();
        });
    </script>
</body>
</html>
